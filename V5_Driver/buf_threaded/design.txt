1. Aufgabenstellung

Das Programm buf_threaded soll einen Zugriff auf einen Puffer auf einer externen Hardware
simulieren, welcher über einen Treiber geschieht. Der Treiber beinhaltet einen flüchtigen Puffer
der über die Befehle read() und write() sowohl schreib- als auch lesbar ist.
Sowohl die Schreib- als die Les-Anfragen können nicht nur über verschiedene Instanzen geschehen,
sondern soll auch multithreaded abgearbeitet werden.
Ist der Puffer voll und ein Schreibthread möchte weitere Daten in den Puffer schreiben, soll
dieser sich solange schlafen legen, bis wieder Platz frei ist.
Analag soll bei einem Lesethread vorgegangen werden: Solange es nichts zu lesen gibt, solange
soll der Lesethread schlafen gelegen werden.
Somit simulieren wir ein klassisches Producer-/Consumer-Verhalten, wobei zu achten ist,
dass Schreib-Threads eine höhere Priorität haben.

2. Kontrollfluss

Für den Zugriff auf den internen Puffer wurde ein mutex (mutex_buffer) definiert. Immer dann,
wenn ein Schreib-Thread ihn beschreiben oder ein Lese-Thread ihn lesen möchte, wird kurz davor
der mutex_buffer gelockt und unmittelbar nach dem Schreiben bzw. Lesen wieder freigegeben.

2.1 Schlafen legen und gegenseitiges Aufwecken

Die Bedingung für das Schreiben in den Puffer ist, dass freier Speicherplatz zur Verfügung steht.
Ist diese Bedingung nicht gegeben, legt sich der Schreibthread schlafen. Dies wird mit einer
write waitqueue gemacht, die beim Aufwecken nochmals die Bedingung überprüft und sich ggf.
wieder schlafen legt, falls diese nicht zutrifft.
Hat ein Lesethread alle zur Verfügung stehenden Daten gelesen, wird sowohl der Lese-, als auch
der Schreibzeiger wieder auf 0 gesetzt und anschließend wird der Schreibthread aufgeweckt
der die (restlichen) Daten in den Puffer schreibt.

2.2 Kontrollfluß des Schreibthreads

Der Schreibthread muss, bevor er Daten in den Puffer schreibt, wissen, wie viel Speicher noch
zur Verfügung steht. Dieser ergibt sich aus der Differenz zwischen der Puffer-Größe und dem
Schreibzeiger der global im Treiber deklariert ist. Da der Lesethread den Schreibzeiger wieder auf
0 setzt sobald der Lesezeiger dieselbe Position wie der Schreibzeiger hat, wurde für den
Schreibzeiger ein write mutex erstellt, der immer dann gelockt und anschließend wieder freigegeben
wird, wenn entweder der Schreib- oder Lesethread den Schreibzeiger setzen wollen.
Da beim Auslesen des freien Speicherplatzes - und somit bei der Berechnung die jedes mal geschieht -
die Position des Schreibzeigers miteinfließt, müsste man bei jedem Auslesen ein lock um den
Schreibzeiger machen. Dies ist jedoch verherrend, wenn der Schreibthread sich schlafen legt, wenn
er feststellt, dass der Puffer voll ist, da dies zu einem Deadlock führen wird, wenn ein Lesethread
den Schreibzeiger wieder auf 0 setzen möchte, um dann anschließend den Schreibthread aufzuwecken,
was nie geschehen wird, da der Schreibthread die Ressource belegt. Um diesen Konflikt zu vermeiden
wurde eine atomic_t free_space Variable angelegt, die immer dann atomar gesetzt wird, wenn der
Schreibzeiger modifiziert wird. Anschließend kann der Schreibthread beliebig oft mit atomic_read
den zuvor berechneten freien Speicherplatz auslesen und sich ohne Gefahr schlafen legen, da nun
kein Lock mehr nötig ist um die Datenintegrität sicher zu stellen.
